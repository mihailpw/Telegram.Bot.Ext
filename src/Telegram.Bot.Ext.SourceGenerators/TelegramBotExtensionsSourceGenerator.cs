using System;
using System.Linq;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;
using Telegram.Bot.Ext.SourceGenerators.Utils;

namespace Telegram.Bot.Ext.SourceGenerators;

[Generator]
public class TelegramBotExtensionsSourceGenerator : ISourceGenerator
{
    private const string TelegramBotAssemblyName = "Telegram.Bot";
    private const string ClassName = "TelegramBotClientExt";

    public void Initialize(GeneratorInitializationContext context)
    {
    }

    public void Execute(GeneratorExecutionContext context)
    {
        var telegramBotAssemblyIdentity =
            context.Compilation.SourceModule.ReferencedAssemblies.First(a => a.Name == TelegramBotAssemblyName);
        var telegramBotReference =
            context.Compilation.References.First(r => r.Display?.Contains(TelegramBotAssemblyName) == true);
        var telegramBotAssembly = Assembly.LoadFrom(((PortableExecutableReference)telegramBotReference).FilePath!);
        if (telegramBotAssemblyIdentity.Version != telegramBotAssembly.GetName().Version)
            throw new InvalidOperationException($"Versions of {TelegramBotAssemblyName} are different");

        var telegramBotClientExtensionsType =
            telegramBotAssembly.ExportedTypes.First(t => t.Name == "TelegramBotClientExtensions");
        var chatIdType = telegramBotAssembly.ExportedTypes.First(t => t.Name == "ChatId");

        var sb = new StringBuilder();
        AppendClass(sb, true);

        foreach (var methodInfo in telegramBotClientExtensionsType.GetMethods())
        {
            var parameters = methodInfo.GetParameters();
            if (!parameters.Any(p => p.ParameterType == chatIdType && p.Name == "chatId"))
                continue;
            AppendMethod(sb, methodInfo, parameters);
        }

        AppendClass(sb, false);

        var resultCode = CSharpSyntaxTree.ParseText(sb.ToString()).GetRoot().NormalizeWhitespace().SyntaxTree
            .GetText().ToString();
        context.AddSource($"{ClassName}.g.cs", SourceText.From(resultCode, Encoding.UTF8));
    }

    private static void AppendClass(StringBuilder sb, bool isStart)
    {
        sb.Append(isStart
            ? $$"""
              // <auto-generated/>

              using Telegram.Bot.Ext.Features.Users;
              using Telegram.Bot.Ext.Features.Users.Models;

              namespace Telegram.Bot.Ext
              {
                  public static partial class {{ClassName}}
                  {
              """
            : """
                  }
              }
              """);
    }

    private static void AppendMethod(StringBuilder sb, MethodInfo methodInfo, ParameterInfo[] parameters)
    {
        var returnTypeName = "Task";
        if (methodInfo.ReturnType.IsGenericType)
            returnTypeName = $"Task<IReadOnlyList<{methodInfo.ReturnType.GenericTypeArguments.First().GetFullName()}>>";
        var generatingParameters = parameters.Skip(1).ToList();
        sb.Append($"""
                    public static {returnTypeName} {methodInfo.Name}(
                        this ITelegramBotClient botClient,
                        IUsersProvider usersProvider,
                        Role role,
                    """);
        foreach (var parameterInfo in generatingParameters)
        {
            if (parameterInfo.Name == "chatId")
                continue;

            sb.Append($"{parameterInfo.ParameterType.GetFullName()} {parameterInfo.Name}{(parameterInfo.IsOptional ? " = default" : "")},");
        }

        sb.Length--;
        sb.Append($"""
                   )
                      => usersProvider.ForAllAsync(role,
                          chatId => botClient.{methodInfo.Name}(
                  """);
        foreach (var parameterInfo in generatingParameters)
        {
            sb.Append($"{parameterInfo.Name},");
        }
        sb.Length--;
        sb.Append("));");
    }
}
